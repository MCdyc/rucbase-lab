在数据库存储系统中，**帧**、**页面** 和 **磁盘** 是存储管理的核心概念，它们之间的关系如下：

---

### **1. 概念解析**
#### **帧（Frame）**
- **定义**: 缓冲池（Buffer Pool）中的一个固定大小的内存块，用于缓存磁盘中的页面。
- **作用**: 
  - 缓冲池由多个帧组成，每个帧可以存放一个页面的数据。
  - 帧是内存中的单位，用于临时存储从磁盘加载的页面。
- **特点**:
  - 帧的大小通常与页面大小相同（如 4KB）。
  - 帧的数量受限于缓冲池的大小。

#### **页面（Page）**
- **定义**: 磁盘上的数据存储单位，通常是固定大小的块（如 4KB）。
- **作用**:
  - 页面是磁盘上的逻辑存储单位。
  - 数据库中的表、索引等数据都以页面为单位存储在磁盘上。
- **特点**:
  - 页面是磁盘 I/O 的基本单位。
  - 页面可以被加载到缓冲池中的帧中进行操作。

#### **磁盘（Disk）**
- **定义**: 数据的永久存储设备。
- **作用**:
  - 磁盘用于存储数据库的所有数据。
  - 页面存储在磁盘文件中，文件由多个页面组成。
- **特点**:
  - 磁盘 I/O 是数据库性能的瓶颈，缓冲池的设计目标是减少磁盘 I/O。

---

### **2. 帧、页面与磁盘的关系**
1. **磁盘中的页面**:
   - 数据库文件存储在磁盘上，文件由多个页面组成。
   - 每个页面有一个唯一的标识符（`PageId`），通常由文件描述符（`fd`）和页面编号（`page_no`）组成。

2. **缓冲池中的帧**:
   - 缓冲池是内存中的一块区域，用于缓存磁盘中的页面。
   - 缓冲池由多个帧组成，每个帧可以存放一个页面的数据。
   - 当需要访问某个页面时，首先检查缓冲池中是否有该页面（通过页表 `page_table_` 查找）。
     - 如果页面在缓冲池中（命中），直接返回。
     - 如果页面不在缓冲池中（未命中），从磁盘加载页面到缓冲池中的一个空闲帧。

3. **帧与页面的映射**:
   - 页表（`page_table_`）维护页面 ID（`PageId`）到帧 ID（`frame_id_t`）的映射。
   - 当页面被加载到缓冲池时，页表会记录页面所在的帧编号。

---

### **3. 数据流示例**
以下是帧、页面与磁盘之间的交互流程：

#### **读取页面**
1. 应用程序请求读取某个页面（`PageId`）。
2. 缓冲池管理器（`BufferPoolManager`）检查页表：
   - 如果页面在缓冲池中（命中），直接返回对应帧中的数据。
   - 如果页面不在缓冲池中（未命中）：
     1. 从磁盘加载页面到缓冲池中的一个空闲帧。
     2. 更新页表，记录页面与帧的映射关系。
     3. 返回帧中的数据。

#### **写入页面**
1. 应用程序修改某个页面的数据。
2. 页面被标记为脏页（`is_dirty = true`）。
3. 当缓冲池需要腾出空间时，脏页会被写回磁盘（通过 `DiskManager::write_page`）。

---

### **4. 数据结构关系**
#### **缓冲池管理器（`BufferPoolManager`）**
- **职责**: 管理缓冲池中的帧与磁盘页面之间的映射。
- **核心数据结构**:
  1. **页表（`page_table_`）**:
     - 类型: `std::unordered_map<PageId, frame_id_t, PageIdHash>`
     - 作用: 记录页面 ID 到帧 ID 的映射。
  2. **空闲帧列表（`free_list_`）**:
     - 类型: `std::list<frame_id_t>`
     - 作用: 记录缓冲池中空闲帧的编号。
  3. **替换策略（`Replacer`）**:
     - 类型: `Replacer`
     - 作用: 当缓冲池没有空闲帧时，选择一个帧进行淘汰。

#### **页面（`Page`）**
- **职责**: 表示缓冲池中的一个页面。
- **核心属性**:
  1. **页面 ID（`id_`）**:
     - 页面在磁盘中的唯一标识符。
  2. **脏页标志（`is_dirty_`）**:
     - 表示页面是否被修改。
  3. **引用计数（`pin_count_`）**:
     - 表示页面被固定的次数。

#### **磁盘管理器（`DiskManager`）**
- **职责**: 管理磁盘文件的读写操作。
- **核心方法**:
  1. **`read_page`**:
     - 从磁盘读取页面数据到缓冲池。
  2. **`write_page`**:
     - 将缓冲池中的页面数据写回磁盘。

---

### **5. 示例代码**
以下是帧、页面与磁盘交互的一个示例：

#### **读取页面**
```cpp
Page *BufferPoolManager::fetch_page(PageId page_id) {
    std::lock_guard<std::mutex> lock(latch_);

    // 检查页表
    auto it = page_table_.find(page_id);
    if (it != page_table_.end()) {
        // 页面在缓冲池中
        frame_id_t frame_id = it->second;
        Page *page = &pages_[frame_id];
        page->pin_count_++; // 增加引用计数
        return page;
    }

    // 页面不在缓冲池中
    frame_id_t frame_id;
    if (!find_victim_page(&frame_id)) {
        return nullptr; // 无法找到空闲帧
    }

    // 如果是脏页，写回磁盘
    Page *victim_page = &pages_[frame_id];
    if (victim_page->is_dirty_) {
        disk_manager_->write_page(victim_page->id_.fd, victim_page->id_.page_no, victim_page->data_, PAGE_SIZE);
    }

    // 从磁盘加载页面
    disk_manager_->read_page(page_id.fd, page_id.page_no, victim_page->data_, PAGE_SIZE);

    // 更新页表和页面元数据
    page_table_.erase(victim_page->id_);
    page_table_[page_id] = frame_id;
    victim_page->id_ = page_id;
    victim_page->is_dirty_ = false;
    victim_page->pin_count_ = 1;

    return victim_page;
}
```

---

### **6. 总结**
- **帧**: 缓冲池中的内存块，用于缓存磁盘页面。
- **页面**: 磁盘上的数据存储单位，可以被加载到帧中。
- **磁盘**: 数据的永久存储设备，页面存储在磁盘文件中。
- **缓冲池管理器**: 负责管理帧与页面之间的映射，减少磁盘 I/O。

通过缓冲池管理器，数据库系统可以高效地在内存和磁盘之间调度页面，从而提升性能。